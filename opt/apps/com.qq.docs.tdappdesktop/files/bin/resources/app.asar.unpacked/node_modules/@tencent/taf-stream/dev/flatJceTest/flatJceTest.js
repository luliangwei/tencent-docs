/**
 * Created by czzou on 2017/10/23.
 */
var Taf = require("../../libjce");
require('heapdump');
var DecodeTest = require("./DecodeTestProxy.js").DecodeTest;

var testStr = new Array(200).join("abcdef");

var tempArr = [];

function printMemUse(){
    var memUse = process.memoryUsage();
    console.log("heapUsed + external:",memUse.heapUsed + memUse.external,
        "heapUsed:",memUse.heapUsed,
        "external:",memUse.external,
        "tempArr:",tempArr.length);
}

function Test(structClass, decodeFn, tempLength){
    tempLength = tempLength || Number.MAX_SAFE_INTEGER;
    tempArr.length = 0;
    var temp = new structClass();
    temp.int1 = 555;
    temp.int2 = 555;
    temp.str1 = testStr;
    temp.str2 = testStr;
    temp.str3 = testStr;
    temp.str4 = testStr;
    temp.str5 = testStr;
    temp.str6 = testStr;
    temp.str7 = testStr;
    temp.str8 = testStr;
    temp.str9 = testStr;
    temp.str10 = testStr;
    var ost = new Taf.JceOutputStream();
    ost.writeStruct(1, temp);
    var buffer = ost.getBinBuffer().toNodeBuffer();
    console.log("daxiao:",buffer.length)
    console.time("耗时：")
    var decodeTimes = 100000;
    for(var i = 0; i<decodeTimes; i++){
        tempArr[i%tempLength] = decodeFn(structClass, new Taf.BinBuffer(Buffer.from(buffer)));
        //tempArr.push(decodeFn(structClass, new Taf.BinBuffer(Buffer.from(buffer))));
        //tempArr.push(decodeFn(structClass, new Taf.BinBuffer(buffer)));
        //if( i % 10000 == 0){
        //    printMemUse();
        //}
    }

    console.log("解码次数：",decodeTimes);
    console.timeEnd("耗时：");
    printMemUse();
}

//jce协议特点：一次性解码struct，访问一个字段的时候，必须解码整个sturct
// 1⃣️ 访问属性个数不影响解码速度
// 2⃣️ 其他字段个数，字段内容大小影响解码速度
//function decode2prop(structClass, data) {
//    var ist = new Taf.JceInputStream(data);
//    var tst = ist.readStruct(1, true, structClass);
//    var str1 = tst.str1;
//    var str2 = tst.str2;
//
//    return tst;
//}

//function decode5prop(structClass, data) {
//    var ist = new Taf.JceInputStream(data);
//    var tst = ist.readStruct(1, true, structClass);
//    var str1 = tst.str1;
//    var str2 = tst.str2;
//    var str3 = tst.str3;
//    var str4 = tst.str4;
//    var str5 = tst.str5;
//
//    return tst;
//}

//function decode10prop(structClass, data) {
//    var ist = new Taf.JceInputStream(data);
//    var tst = ist.readStruct(1, true, structClass);
//
//    var int1 = tst.int1;
//    var int2 = tst.int2;
//    var str1 = tst.str1;
//    var str2 = tst.str2;
//    var str3 = tst.str3;
//    var str4 = tst.str4;
//    var str5 = tst.str5;
//    var str6 = tst.str6;
//    var str7 = tst.str7;
//    var str8 = tst.str8;
//    var str9 = tst.str9;
//    var str10 = tst.str10;
//    //console.log(tst);
//    return tst;
//}

function decode8prop(structClass, data) {
    var ist = new Taf.JceInputStream(data);
    var tst = ist.readStruct(1, true, structClass);

    tst.int1;
    tst.int2;
    tst.str1;
    tst.str2;
    tst.str3;
    tst.str4;
    tst.str5;
    tst.str6;
    tst.str7;
    tst.str8;
    //console.log(tst);
    return tst;
}

var tempLength = 20;

//console.log("Jce解码20%属性测试");
//Test(DecodeTest.TestStruct, decode2prop);

//console.log("Flat解码20%属性测试");
//Test(DecodeTest.FlatTestStruct, decode2prop);
//
//console.log("Jce解码50%属性测试");
//Test(DecodeTest.TestStruct, decode5prop, tempLength);
//console.log("Flat解码50%属性测试");
//Test(DecodeTest.FlatTestStruct, decode5prop,tempLength);

var testStr2 = new Array(100).join("ghijkm");
var bufferArr = [];
for(var i = 0; i< 100000;i++){
    bufferArr.push(Buffer.from(testStr2));
}


Test(DecodeTest.TestStruct, decode8prop, tempLength);
//Test(DecodeTest.FlatTestStruct, decode8prop,tempLength);

//Test(DecodeTest.TestStruct, decode10prop, tempLength);
//Test(DecodeTest.FlatTestStruct, decode10prop, tempLength);

printMemUse();
console.log(bufferArr.length);

//dump堆内存
//setTimeout(function(){
//    heapdump.writeSnapshot("jce.heapsnapshot");
//},3000)


//setInterval(function () {
//    printMemUse();
//},3000);