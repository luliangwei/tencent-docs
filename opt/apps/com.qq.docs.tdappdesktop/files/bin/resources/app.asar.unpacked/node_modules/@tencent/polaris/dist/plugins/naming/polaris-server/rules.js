"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuleProcessor = void 0;
const types_1 = require("./types");
class RuleProcessor {
    constructor(unbox) {
        this.unbox = unbox;
        /**
         * (empty function)
         */
    }
    procRules(rules) {
        const result = [];
        rules.forEach(({ sources, destinations }) => {
            if (sources && destinations) {
                result.push({
                    sources: this.procSourceRules(sources),
                    destinations: this.procDestinationRules(destinations)
                });
            }
        });
        return result;
    }
    produceMetadata(metadata) {
        const destMetadata = Object.create(null);
        if (metadata) {
            Object.keys(metadata).forEach((key) => {
                const matchString = metadata[key];
                if (matchString.value) {
                    if (matchString.type === types_1.MatchStringType.REGEX) {
                        destMetadata[key] = new RegExp(this.unbox(matchString.value, ""));
                    }
                    else {
                        destMetadata[key] = this.unbox(matchString.value, "");
                    }
                }
            });
        }
        return destMetadata;
    }
    procSourceRules(rules) {
        const result = [];
        rules.forEach(({ service, metadata }) => {
            const serviceName = this.unbox(service, "");
            if (serviceName) {
                const source = {
                    service: serviceName
                };
                if (metadata) {
                    source.metadata = this.produceMetadata(metadata);
                }
                result.push(source);
            }
        });
        return result;
    }
    procDestinationRules(rules) {
        const result = [];
        rules.forEach(({ service, metadata, priority, transfer, weight }) => {
            const serviceName = this.unbox(service, "");
            if (serviceName) {
                const dest = {
                    service: serviceName,
                    priority: this.unbox(priority, 9),
                    weight: this.unbox(weight, 0)
                };
                if (transfer) {
                    dest.transfer = this.unbox(transfer, "");
                }
                if (metadata) {
                    dest.metadata = this.produceMetadata(metadata);
                }
                result.push(dest);
            }
        });
        return result;
    }
}
exports.RuleProcessor = RuleProcessor;
//# sourceMappingURL=rules.js.map