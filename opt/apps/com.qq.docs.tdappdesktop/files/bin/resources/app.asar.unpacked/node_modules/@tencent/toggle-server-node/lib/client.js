"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var events_1 = require("events");
var util_1 = require("./util");
var index_1 = require("./index");
var constants = require("./constants");
var DatasetTypePrecise = 1;
var DatasetTypePercentage = 2;
var Client = /** @class */ (function (_super) {
    __extends(Client, _super);
    function Client(repository, metrics, strategies) {
        var _this = _super.call(this) || this;
        _this.repository = repository;
        _this.metrics = metrics;
        _this.strategies = strategies;
        for (var _i = 0, strategies_1 = strategies; _i < strategies_1.length; _i++) {
            var strategy = strategies_1[_i];
            if (typeof strategies !== 'object'
                || !strategy
                || !strategy.name
                || typeof strategy.name !== 'string'
                || !strategy.isEnabled
                || typeof strategy.isEnabled !== 'function') {
                throw new Error('Invalid strategy data / interface');
            }
        }
        return _this;
    }
    Client.prototype.isEnabled = function (name, context, fallback, abTestInfo, hasDataset) {
        if (hasDataset === void 0) { hasDataset = constants.WithoutDataset; }
        /**
         * In the following code, value is default to false, and we only care about
         * the cases that value are true
         */
        var feature = this.repository.getToggle(name);
        var abTestId = '-1';
        var result = {};
        if (!feature) {
            // if feature not exist, try valid abTestInfo, then fallback
            result = this.getAbTestInfoValueAndDataset(abTestInfo, name);
            if (!!result.toggleValue) {
                abTestId = abTestInfo.abTestId;
            }
            else {
                result.toggleValue = fallback && typeof fallback === 'boolean' ? fallback : false;
            }
        }
        else {
            // if feature exist
            result = this.getAbTestInfoValueAndDataset(abTestInfo, name);
            if (feature.isAbtFirst && !!result.toggleValue) {
                // 1. use a/b test config if isAbtFirst set to true
                abTestId = abTestInfo.abTestId;
            }
            else if (feature.value !== constants.FEATURE_VALUE_STR_TRUE) {
                // 2. use off dataset if feature is closed
                if (hasDataset == constants.WithDataset) {
                    result = this.getDatasetFromStrategyGroup(context, feature.offDatasetEx);
                }
                result.toggleValue = false;
            }
            else if (!this.checkTimeLimitsMatch(feature.timeLimitType, feature.timeLimits)) {
                // 3. decide if current hit any time limit
                if (hasDataset == constants.WithDataset) {
                    result = this.getDatasetFromStrategyGroup(context, feature.offDatasetEx);
                }
                result.toggleValue = fallback;
            }
            else {
                // 4. default mode
                var hasCaculatedMap = {};
                result = this.isEnableCalculator(feature, context, hasCaculatedMap, hasDataset);
            }
        }
        // Save feature event
        // If feature not found, set id in feature event to -1
        feature = feature ? feature : { id: -1, name: name };
        this.metrics.saveFeatureEvent(feature, result, context, abTestId);
        return result;
    };
    Client.prototype.getStrategy = function (name) {
        return this.strategies.find(function (strategy) { return strategy.name === name; });
    };
    Client.prototype.getAbTestInfoValueAndDataset = function (abTestInfo, wantParamKey) {
        if (!abTestInfo) {
            return {};
        }
        if (!abTestInfo.platform) {
            // 给予默认值，向前兼容Roma实验
            abTestInfo.platform = index_1.ROMA_AB_TEST;
        }
        if (!abTestInfo.abTestId || typeof abTestInfo.abTestId !== 'string') {
            return {};
        }
        if (abTestInfo.platform === index_1.ROMA_AB_TEST) {
            return this.getRomaAbTestInfo(abTestInfo, wantParamKey);
        }
        if (abTestInfo.platform === index_1.TAB_AB_TEST) {
            return this.getTabAbTestInfo(abTestInfo, wantParamKey);
        }
        return {};
    };
    Client.prototype.getRomaAbTestInfo = function (abTestInfo, wantParamKey) {
        if (!abTestInfo.params || typeof abTestInfo.params !== 'object') {
            return {};
        }
        if (!abTestInfo.params[wantParamKey] || typeof abTestInfo.params[wantParamKey] !== 'string') {
            return {};
        }
        return { toggleValue: abTestInfo.params[wantParamKey] === constants.TRUE_STR, type: constants.DataTypeMap };
    };
    Client.prototype.getTabAbTestInfo = function (abTestInfo, wantParamKey) {
        // 先判断用户是否手动传参数信息到abTestInfo中, 如果有就优先使用
        if (!!abTestInfo.params && abTestInfo.params[constants.TabToggleValField] !== undefined) {
            if (abTestInfo.params[constants.TabToggleValField] === constants.TabToggleOn) {
                return { toggleValue: true, dataset: abTestInfo.params, type: constants.DataTypeMap };
            }
            return { toggleValue: false, dataset: abTestInfo.params, type: constants.DataTypeMap };
        }
        var expInfo = this.repository.getExpInfoByExpId(abTestInfo.abTestId);
        if (!!expInfo && !!expInfo.params) {
            if (expInfo.params[constants.TabToggleNameField] !== wantParamKey) {
                return {};
            }
            if (expInfo.params[constants.TabToggleValField] === constants.TabToggleOn) {
                return { toggleValue: true, dataset: expInfo.params, type: constants.DataTypeMap };
            }
            return { toggleValue: false, dataset: expInfo.params, type: constants.DataTypeMap };
        }
        return {};
    };
    Client.prototype.timeLimitMatch = function (timeLimitType, timeStr, crt, isStart) {
        try {
            if (timeStr.length === 0) {
                return true;
            }
            if (timeLimitType === constants.FEATURE_TIME_LIMIT_TYPE_DAILY) {
                timeStr = "2006-03-04 " + timeStr;
            }
            var toCompare = moment(timeStr);
            if (isStart) {
                return !toCompare.isAfter(crt);
            }
            return !toCompare.isBefore(crt);
        }
        catch (error) {
            this.emit('error', "time limit match failed: " + error);
            return false;
        }
    };
    // decide if there is a time limit restricted
    // if not, return false by default;
    // if there is, return false on hit, return true on miss
    Client.prototype.checkTimeLimitsMatch = function (type, timeLimits) {
        if (type === constants.FEATURE_TIME_LIMIT_TYPE_DAILY || type === constants.FEATURE_TIME_LIMIT_TYPE_FIXED) {
            var crtTime = util_1.getAdjustedShanghaiTime();
            if (type === constants.FEATURE_TIME_LIMIT_TYPE_DAILY) {
                // YYYY-MM-DD is ignored, we just convert it to the same DATE as startTime and endTime for comparison
                crtTime.set('year', 2006);
                crtTime.set('month', 2); // 2 as March
                crtTime.set('date', 4);
            }
            for (var _i = 0, timeLimits_1 = timeLimits; _i < timeLimits_1.length; _i++) {
                var tl = timeLimits_1[_i];
                if (this.timeLimitMatch(type, tl.startTime, crtTime, true)
                    && this.timeLimitMatch(type, tl.endTime, crtTime, false)) {
                    return true; // hit
                }
            }
            return false; // miss
        }
        return true;
    };
    Client.prototype.isEnableCalculator = function (feature, context, hasCaculatedMap, hasDataset) {
        var featureIdStr = feature.id.toString();
        if (hasCaculatedMap[featureIdStr] !== undefined) {
            return { toggleValue: hasCaculatedMap[featureIdStr] };
        }
        if (feature.value !== constants.FEATURE_VALUE_STR_TRUE) {
            hasCaculatedMap[featureIdStr] = false;
            return { toggleValue: false };
        }
        // 1.decide if current hit any time limit
        if (!this.checkTimeLimitsMatch(feature.timeLimitType, feature.timeLimits)) {
            hasCaculatedMap[featureIdStr] = false;
            return { toggleValue: false };
        }
        // 2.judge prerequisite
        if (!this.judgePrerequisite(feature, context, hasCaculatedMap)) {
            var result_1 = {};
            if (hasDataset === constants.WithDataset) {
                result_1 = this.getDatasetFromStrategyGroup(context, feature.offDatasetEx);
            }
            result_1.toggleValue = false;
            return result_1;
        }
        // 3.get toggle value and variations from strategy groups
        var result = this.getToggleValueAndDatasetFromStrategyGruops(feature, context, hasCaculatedMap, hasDataset);
        return result;
    };
    // judgePrerequisite 深度遍历先决条件
    Client.prototype.judgePrerequisite = function (feature, context, hasCaculatedMap) {
        var featureIdStr = feature.id.toString();
        for (var _i = 0, _a = feature.prerequisites; _i < _a.length; _i++) {
            var prerequisite = _a[_i];
            var id = prerequisite.versionId.toString();
            var result = this.isEnableCalculator(this.repository.getPrerequisite(id), context, hasCaculatedMap, constants.WithoutDataset);
            var statusValue = prerequisite.statusValue === constants.TRUE_STR;
            if (result.toggleValue !== statusValue) {
                var prerequisiteName = this.repository.getPrerequisite(id).name;
                var prerequisiteVer = this.repository.getPrerequisite(id).version;
                this.emit('warn', "feature prerequisite is not match, the prerequisite is " + prerequisiteName + "(v" + prerequisiteVer + ")");
                hasCaculatedMap[featureIdStr] = false;
                return false;
            }
        }
        return true;
    };
    // getToggleValueAndDatasetFromStrategyGruops 从策略组中获取开关值和配置
    Client.prototype.getToggleValueAndDatasetFromStrategyGruops = function (feature, context, hasCaculatedMap, hasDataset) {
        for (var _i = 0, _a = feature.strategyGroups; _i < _a.length; _i++) {
            var strategyGroup = _a[_i];
            if (this.judgeStrategy(feature.id, strategyGroup, context, feature.name, hasCaculatedMap)) {
                var datasetEx = strategyGroup.datasetEx;
                if (hasDataset === constants.WithDataset) {
                    var result = this.getDatasetFromStrategyGroup(context, datasetEx);
                    result.toggleValue = datasetEx.toggleValue;
                    return result;
                }
                if (datasetEx.toggleValue === undefined) {
                    datasetEx.toggleValue = true;
                }
                return { toggleValue: datasetEx.toggleValue };
            }
        }
        // 未命中策略, 返回false, 以及根据hasDataset返回配置
        if (hasDataset === constants.WithDataset) {
            var result = this.getDatasetFromStrategyGroup(context, feature.defaultDatasetEx);
            result.toggleValue = false;
            return result;
        }
        return { toggleValue: false };
    };
    // judgeStrategy 判断是否命中策略
    Client.prototype.judgeStrategy = function (featureId, strategyGroup, context, featureName, hasCaculatedMap) {
        var featureIdStr = featureId.toString();
        var strategies = strategyGroup.strategies;
        if (strategies.length === 0) {
            hasCaculatedMap[featureIdStr] = true;
            return true;
        }
        var isStgRelationAnd = strategyGroup.stgRelation === constants.STG_RELATION_AND;
        for (var _i = 0, strategies_2 = strategies; _i < strategies_2.length; _i++) {
            var fStrategy = strategies_2[_i];
            var strategy = this.getStrategy(fStrategy.name || '');
            if (!strategy) {
                this.emit('warn', "Missing strategy \"" + fStrategy.name + "\" for toggle \"" + featureName + "\". ");
                if (isStgRelationAnd) {
                    hasCaculatedMap[featureIdStr] = false;
                    return false;
                }
                continue;
            }
            var stgRes = strategy.isEnabled(fStrategy.parameters, context);
            // and关系有一个false，返回false
            if (isStgRelationAnd && !stgRes) {
                hasCaculatedMap[featureIdStr] = false;
                return false;
            }
            // 默认按照or处理，有一个true，返回true
            if (!isStgRelationAnd && stgRes) {
                hasCaculatedMap[featureIdStr] = false;
                return true;
            }
        }
        // 要不and关系全部为true，返回true; 要不or关系全部为false，返回false
        hasCaculatedMap[featureIdStr] = isStgRelationAnd;
        return isStgRelationAnd;
    };
    Client.prototype.getDatasetFromStrategyGroup = function (context, strategyGroup) {
        if (strategyGroup.datasetType === DatasetTypePrecise) {
            // 精确匹配
            return {
                dataset: strategyGroup.dataset.data,
                datasetId: strategyGroup.dataset.datasetId,
                versionId: strategyGroup.dataset.versionId,
                type: strategyGroup.dataset.type,
                value: strategyGroup.dataset.value,
            };
        }
        if (strategyGroup.datasetType === DatasetTypePercentage) {
            // 百分比匹配
            // 1.获取百分比值
            var percent = 0;
            var rolloutBase = strategyGroup.rolloutBase;
            if (!!context[rolloutBase]) {
                // 取context中的rolloutBase
                if (typeof context[rolloutBase] === 'string') {
                    var temp = context[rolloutBase];
                    percent = util_1.getHashPercentNumber(temp);
                }
                else {
                    // 非string类型,使用纯随机数
                    percent = util_1.getRandomPercentNumber();
                }
            }
            else if (!!context.properties && !!context.properties[rolloutBase]) {
                // 取context.properties中的rolloutBase
                percent = util_1.getHashPercentNumber(context.properties[rolloutBase]);
            }
            else {
                // 使用纯随机数
                percent = util_1.getRandomPercentNumber();
            }
            // 2.根据百分比值查找对应的data
            var currentPercent = 0;
            for (var _i = 0, _a = strategyGroup.rolloutWeights; _i < _a.length; _i++) {
                var rolloutWeight = _a[_i];
                currentPercent += rolloutWeight.weight;
                // percent小于当前rolloutWeight.weight之和, 则命中, 返回data
                if (percent <= currentPercent) {
                    return {
                        dataset: rolloutWeight.data,
                        datasetId: rolloutWeight.datasetId,
                        versionId: rolloutWeight.versionId,
                        type: rolloutWeight.type,
                        value: rolloutWeight.value,
                    };
                }
            }
        }
        return { dataset: {}, datasetId: 0, versionId: 0, type: '', value: '' };
    };
    return Client;
}(events_1.EventEmitter));
exports.default = Client;
//# sourceMappingURL=client.js.map